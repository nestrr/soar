import type { FullRoomInfo, PeerKeyData, UserInfo } from "../../ServerTypes";
import type { types as MediasoupTypes } from "mediasoup";
import autoBind from "auto-bind";
import redis from "../../lib/redis";
import {
  consumerRepository,
  peerRepository,
  producerRepository,
  roomRepository,
  routerRepository,
  transportRepository,
} from "./repositories";
import logs from "../../lib/logger";
import { publishCheckRequest } from "./cleanup/producer";
class ServerStateActions {
  userPeerKeys: Record<string, PeerKeyData> = {};
  routers: Record<string, MediasoupTypes.Router> = {};
  transports: Record<string, MediasoupTypes.WebRtcTransport> = {};
  producers: Record<string, MediasoupTypes.Producer> = {};
  consumers: Record<string, MediasoupTypes.Consumer> = {};

  constructor() {
    logs.debug("CONSTRUCTING SERVER STATE --->");
    this.userPeerKeys = {};
    this.routers = {};
    this.transports = {};
    this.producers = {};
    this.consumers = {};
    autoBind(this);
  }

  /**
   * Get info on a room
   * @param roomId The room ID of the room
   * @returns the room information
   * TODO: consider speeding up.
   */
  async getRoom(roomId: string): Promise<FullRoomInfo | null> {
    const room = await roomRepository.fetch(roomId);

    if (!room.routerId || !this.routers[room.routerId]) {
      logs.warn("Room not found - getRoom! %s %s", roomId, room.routerId);
      return null;
    }
    const peerKeys = await redis.sMembers(`memberPeerKeys:room:${roomId}`);
    const router = this.routers[room.routerId];
    return { ...room, id: roomId, peerKeys, router };
  }

  /**
   * Gets room size
   * @param roomId The room ID of the room
   * @returns The number of people in this room
   */
  async getRoomSize(roomId: string) {
    return await redis.sCard(`memberPeerKeys:room:${roomId}`);
  }

  /**
   * Gets room peers
   * @param roomId The room ID
   * @returns The list of room peers
   * TODO: consider speeding up?
   */
  async getProducingRoomPeers(roomId: string) {
    const peerKeys = await redis.sMembers(`memberPeerKeys:room:${roomId}`);
    const peers = [];
    for (const peerKey of peerKeys) {
      const { userId, producerId, displayName, verified } =
        await peerRepository.fetch(peerKey);
      if (producerId) {
        // NOT returning consumer since that doesn't seem necessary
        peers.push({
          userId,
          displayName,
          verified,
          producerId: producerId as string,
        });
      }
    }
    return peers;
  }

  /**
   * Stores the room in server state
   * @param roomId - The ID of the room
   * @param routerId - The router for this room
   */
  async storeRoom(roomId: string, routerId: string) {
    // 1. Store room information in Redis hash.
    if (!routerId) return;
    await roomRepository.save(roomId, {
      routerId,
      sticky: false,
    });
  }

  /**
   * Stores router in cache and memory
   * @param router The router
   * @param workerId - The worker ID generated by mediasoup
   */
  async storeRouter(
    router: MediasoupTypes.Router,
    config: MediasoupTypes.RtpCodecCapability[]
  ) {
    // 1. Save router information to Redis router hash so it can be recreated if needed.
    await routerRepository.save(router.id, {
      config: JSON.stringify(config),
    });

    // 2. Save the Mediasoup router itself in local memory, since its event handlers etc can't be cached.
    this.routers[router.id] = router;
  }

  /**
   * Check if room exists
   * @param roomId The room ID
   * @returns If the room exists
   * TODO: check if we need to check the cache too?
   */
  async existsRoom(roomId: string) {
    const room = await roomRepository.fetch(roomId);
    return Object.keys(room).length > 0;
  }

  /**
   * Removes a room from server state
   * @param roomId The room ID
   */
  async removeRoom(roomId: string) {
    // 1. Remove all peer key records for this room
    await redis.del(`memberPeerKeys:room:${roomId}`);

    // 2. Remove the router associated with this room.
    const { routerId } = await roomRepository.fetch(roomId);
    if (routerId) await this.removeRouter(routerId);

    // 3. Remove room from Redis room hash.
    await roomRepository.remove(roomId);
  }

  async removeRouter(routerId: string) {
    // 1. Remove router information from Redis router hash.
    await routerRepository.remove(routerId);

    // 2. Remove Mediasoup router itself from local memory.
    const { [routerId]: _router, ...others } = this.routers;
    this.routers = { ...others };
    logs.info("Removed router %s from state", routerId);
  }

  /**
   * Check if user is in room
   * @param userId The user ID of the user
   * @param roomId The room ID
   * @returns If the user is in the room
   */
  async isUserInRoom(userId: string, roomId: string) {
    return !!this.userPeerKeys[userId]?.[roomId];
  }

  /**
   * Get info on room(s) the user is in, and the peer keys the user has in each of those rooms.
   * @param userId The user ID of the user
   * @param fullInfo - If true, returns the full information on all rooms the user is in. By default, includes all rooms.
   * @param onlyIncludeRooms - If fullInfo is true, only include full information for rooms with these IDs.
   * @returns the user's rooms and peer keys
   */
  async getUserPresence(
    userId: string,
    fullInfo: boolean = false,
    onlyIncludeRooms: string[] = []
  ) {
    if (!fullInfo) {
      return await redis.sMembers(`peerKeys:user:${userId}`);
    }
    const fullPresenceInfo: Record<
      string,
      Record<string, string | undefined>
    > = {};

    const roomsToInclude =
      onlyIncludeRooms.length > 0
        ? onlyIncludeRooms
        : Object.keys(this.userPeerKeys[userId] ?? {});

    for (const roomId of roomsToInclude) {
      if (!this.userPeerKeys[userId]?.[roomId]) {
        console.error("Peer key for roomnot found! Cannot get user presence.");
        continue;
      }
      const peerKey = this.userPeerKeys[userId][roomId];

      fullPresenceInfo[roomId] = await this.getFullUserPresenceInfo(peerKey);
    }
    return fullPresenceInfo;
  }

  async getFullUserPresenceInfo(peerKey: string) {
    const { producerTransportId, consumerTransportId, producerId, consumerId } =
      await peerRepository.fetch(peerKey);

    return {
      peerKey,
      producerId,
      consumerId,
      producerTransportId,
      consumerTransportId,
    };
  }

  /**
   * Store the user in server storage
   * @param userInfo The user information, including user ID and display name
   * @param roomId The room ID of the room they want to join
   */
  async storeUser(userInfo: UserInfo, roomId: string) {
    // 1. Save peer (user-room connection) information in Redis hash.
    const { userId } = userInfo;
    logs.debug("Saving user %s in room %s", userId, roomId);
    await peerRepository.save(`${userId}:${roomId}`, {
      ...userInfo,
      roomId,
      producerTransportId: "",
      consumerTransportId: "",
      producerId: "",
      consumerId: "",
    });
    // 2. Add saved peer entity's key to record of peer keys associated with this user.
    await redis.sAdd(`peerKeys:user:${userId}`, `${userId}:${roomId}`);
    // 3. Add saved peer entity's key to record of peer keys associated with the room.
    await redis.sAdd(`memberPeerKeys:room:${roomId}`, `${userId}:${roomId}`);
    // 4. Store user peer key in local memory.
    this.userPeerKeys[userId] = {
      ...this.userPeerKeys[userId],
      ...{ [roomId]: `${userId}:${roomId}` },
    };
  }

  /**
   * Updates user-related information in all peer records
   * @param userId The user ID
   * @param userInfo The new user details
   */
  async updateUser(userId: string, userInfo: Partial<UserInfo>) {
    if (!userId) {
      logs.warn(
        "User ID empty, could not update user. User info: %O",
        userInfo
      );
      return;
    }
    const peerKeys = await redis.sMembers(`peerKeys:user:${userId}`);
    for (const peerKey of peerKeys) {
      const currentPeerInfo = await peerRepository.fetch(peerKey);
      if (!currentPeerInfo) {
        logs.warn("Could not fetch peer info for peer key %s", peerKey);
        return;
      }
      const { roomId } = currentPeerInfo;
      logs.debug("Updating user %s in room %s", userId, roomId);
      await peerRepository.save(`${userId}:${roomId}`, {
        ...currentPeerInfo,
        ...userInfo,
      });
    }
  }

  /**
   * Removes user's peer data from server state.
   *
   * Specifically, cleans up producer, consumer, transport, and peer repositories.
   * @param peerKey: The peer's entity key
   */
  async removePeerData(peerKey: string) {
    const {
      producerTransportId,
      consumerTransportId,
      producerId,
      consumerId,
      roomId,
    } = await peerRepository.fetch(peerKey);
    logs.warn(`REMOVING  %O`, { peerKey, roomId });
    if (producerTransportId)
      await transportRepository.remove(producerTransportId);
    if (consumerTransportId)
      await transportRepository.remove(consumerTransportId);
    if (producerId) await producerRepository.remove(producerId);
    if (consumerId) await consumerRepository.remove(consumerId);
    await peerRepository.remove(peerKey);
  }

  /**
   * Removes a user from a room in server state
   * @param userId - The user ID of the user
   * @param roomId - The room ID of the room
   */
  async removePeer(peerKey: string) {
    const { userId, roomId } = await peerRepository.fetch(peerKey);
    // 1. Clean up all repositories storing this peer's data.
    await this.removePeerData(peerKey);

    // 2. Remove peer key from record of peer keys associated with room.
    await redis.sRem(`memberPeerKeys:room:${roomId}`, peerKey);

    // 3. Remove peer key from record of peer keys associated with user.
    await redis.sRem(`peerKeys:user:${userId}`, peerKey);

    // 4. Check if user is empty and should be auto-removed (handled separately by Redis stream).
    await publishCheckRequest(userId, "user");
    await publishCheckRequest(roomId, "room");

    const { [roomId]: _room, ...others } = this.userPeerKeys[userId];
    this.userPeerKeys[userId] = { ...others };
    logs.info(
      "Removed peer %s. In-memory userPeerKeys now %O",
      peerKey,
      this.userPeerKeys
    );
  }

  async removePeerByUserRoomIds(userId: string, roomId: string) {
    const peerKey = this.userPeerKeys[userId]?.[roomId];
    // If this user was a peer in the given room
    if (peerKey) {
      await this.removePeer(peerKey);
    }
  }

  /**
   * Removes a user from server state
   * @param userId The user ID
   */
  async removeUser(userId: string) {
    const peerKeys = await redis.sMembers(`peerKeys:user:${userId}`);
    for (const peerKey of peerKeys) {
      logs.warn(`REMOVING USER PEER FROM SERVER STATE ---> %O`, {
        peerKey,
        userId,
      });
      // 1. Remove records of peer keys in rooms this user associated with as well as the peer's more detailed record in peerRepository.
      await this.removePeer(peerKey);
    }

    // 2. Remove set of user's own peer keys.
    await redis.del(`peerKeys:user:${userId}`);

    // 3. Remove user peer key records in local memory.
    const { [userId]: _userToRemove, ...others } = this.userPeerKeys;
    this.userPeerKeys = { ...others };
  }

  /**
   * Stores the transport in server state
   * @param transport - The transport
   * @param userId - The user ID
   * @param roomId - The room ID
   * @param type - The type of transport ("producer" or "consumer")
   */
  async storeTransport(
    transport: MediasoupTypes.WebRtcTransport,
    userId: string,
    roomId: string,
    type: "producer" | "consumer",
    config: MediasoupTypes.WebRtcTransportOptions
  ) {
    const peerKey = this.userPeerKeys[userId][roomId];
    await transportRepository.save(transport.id, {
      peerKey,
      roomId,
      type,
      config: JSON.stringify(config),
    });
    // Uses hSet instead of repository to update a single field instead of fetching the entire record
    const field =
      type === "producer" ? "producerTransportId" : "consumerTransportId";
    await redis.hSet(`peer:${peerKey}`, field, transport.id);
    this.transports[transport.id] = transport;
  }

  /**
   * Returns the transport from server state
   * @param transportId The transport ID
   * @returns The transport
   */
  getTransport(transportId: string) {
    return this.transports[transportId];
  }

  /**
   * Remove transport ID from server state
   * @param transportId The transport ID
   */
  async removeTransport(transportId: string) {
    if (!this.transports[transportId]) return;

    const { [transportId]: _transportToRemove, ...others } = this.transports;

    // 1. Remove transport from Redis transport hash.
    await transportRepository.remove(transportId);

    // 2. Remove transport from local memory.
    this.transports = { ...others };
  }

  /**
   * Check if producer exists
   * @param producerId The producer ID
   * @returns If the producer exists
   */
  existsProducer(producerId: string) {
    return !!this.producers[producerId];
  }

  /**
   * Returns the producer from server state
   * @param producerId The producer ID
   * @returns The producer
   */
  getProducer(producerId: string) {
    return this.producers[producerId];
  }

  // /**
  //  * Updates the producer in server state
  //  * @param producerId Producer ID to update
  //  * @param producer the producer
  //  */
  // updateProducer(producerId: string, producer: MediasoupTypes.Producer) {
  //   if (!this.producers[producerId]) return;
  //   this.producers[producerId].producer = producer;
  // }

  /**
   * Stores the producer in server state
   * @param producer - The producer
   * @param userId - The user ID
   * @param roomId - The room ID
   * @param transportId - The transport ID
   * @param config - The configuration for the producer
   */
  async storeProducer(
    producer: MediasoupTypes.Producer,
    userId: string,
    roomId: string,
    transportId: string,
    config: Record<string, unknown>
  ) {
    await producerRepository.save(producer.id, {
      peerKey: this.userPeerKeys[userId][roomId],
      roomId,
      transportId,
      config: JSON.stringify(config),
    });
    this.producers[producer.id] = producer;
  }

  /**
   * Removes the producer from server state
   * @param producerId The producer ID
   */
  async removeProducer(producerId: string) {
    if (!this.producers[producerId]) return;
    const { [producerId]: _producerToRemove, ...others } = this.producers;

    // 1. Remove producer from Redis producer hash.
    await producerRepository.remove(producerId);

    // 2. Remove producer from local memory.
    this.producers = { ...others };
  }

  /**
   * Check if consumer exists
   * @param consumerId The consumer ID
   * @returns If the consumer exists
   */
  existsConsumer(consumerId: string) {
    return !!this.consumers[consumerId];
  }

  /**
   * Stores the consumer in server state
   * @param consumer - The consumer
   * @param userId - The user ID
   * @param roomId - The room ID
   * @param transportId - The transport ID
   * @param config - The configuration for the consumer
   */
  async storeConsumer(
    consumer: MediasoupTypes.Consumer,
    userId: string,
    roomId: string,
    transportId: string,
    config: Record<string, unknown>
  ) {
    await consumerRepository.save(consumer.id, {
      peerKey: this.userPeerKeys[userId][roomId],
      roomId,
      transportId,
      config: JSON.stringify(config),
    });
    this.consumers[consumer.id] = consumer;
  }

  /**
   * Returns the consumer from server state
   * @param consumerId The consumer ID
   * @returns The consumer
   */
  getConsumer(consumerId: string) {
    return this.consumers[consumerId];
  }

  // /**
  //  *
  //  * @param consumerId - Consumer ID to update
  //  * @param consumer - The consumer
  //  */
  // fetch entity and save it again
  // updateConsumer(consumerId: string, consumer: MediasoupTypes.Consumer) {
  //   this.consumers[consumerId].consumer = consumer;
  // }

  /**
   * Removes the consumer from server state
   * @param consumerId The consumer ID
   */
  async removeConsumer(consumerId: string) {
    if (!this.consumers[consumerId]) return;
    const { [consumerId]: _consumerToRemove, ...others } = this.consumers;
    // 1. Remove consumer from Redis consumer hash.
    await consumerRepository.remove(consumerId);

    // 2. Remove consumer from local memory.
    this.consumers = { ...others };
  }
}
export default class ServerState {
  private static serverState: ServerStateActions;
  constructor() {
    autoBind(this);
  }
  static getInstance() {
    this.serverState = this.serverState ?? new ServerStateActions();
    return this.serverState;
  }
}
